#!/usr/bin/env ruby
require 'json'
require 'erb'
require 'date'
require 'git'


$SOURCE = "#{Dir.getwd}"

class Directory_Manager
  # Gets Current date to define as version
  def get_version()
    return Date.today.to_s.delete! '-'
  end
  
  # Creates all main directories 
  def create_directories()
    %w[/modulefiles/ /toolchain/ /toolchain/build].each { |dir| Dir.mkdir ($SOURCE + dir) }
  end
  # Creates Build directory with current tool data
  def create_build_dir(config, name)
    build_dir = "#{$SOURCE}/toolchain/build/#{name}"
    Dir.mkdir(build_dir) if !File.directory? (build_dir)
    build_dir = "#{build_dir}/#{get_version()}"
    Dir.mkdir(build_dir) if !File.directory? (build_dir)
    Dir.chdir(build_dir)
  end
  
  def create_module_file(prefix, name)
    #module_dir = "#{config.get(:modulefile)}/#{name}/"
    module_dir = "#{$SOURCE}/modulefiles/#{name}/"
    Dir.mkdir(module_dir) if !File.directory? (module_dir)
    
    #template = ERB.new(File.read("#{Dir.getwd}/workload/toolchain.module.erb"))
    #prefix = "#{config.get(:prefix)}"
    
    template = ERB.new <<-EOF
    whatis("ARC: myModuleName()")
    whatis("Version: myModuleVersion()")

    local pkg = pathJoin("<%= prefix %>", myModuleName(), myModuleVersion())
    prepend_path("PATH", pathJoin(pkg, "bin"))
    prepend_path("LD_LIBRARY_PATH", pathJoin(pkg, "lib"))
    EOF

    File.open("#{module_dir}/#{get_version()}.lua", 'w') do |f|
      f.write template.result(binding)
    end

  end

end

class Config
  def initialize(file = nil, dir_manager = nil)
    
    unless file.nil?
      file = JSON.parse(File.read(file), symbolize_names: true)
      tmp = {}
      tmp.store(:params, "")
      tmp.store(:builder, file)

      #DELETE
      tmp_ = {}
      tmp.store(:params, tmp_)
      #DELETE
      
      dir_manager.create_directories()
      

      File.open(".config.json", 'w') do |f|
        f.write JSON.pretty_generate(tmp)
      end
    else
      @config = JSON.parse(File.read(".config.json"), symbolize_names: true)
    end
    #@config = file
  end
  
  # Sets Value to Key
  def set(key, value)
    @config.store(key, value)
  end
  
  # Gets Value from Key
  def get(key)
    @config[key] 
  end
  
  # Gets Hash 
  def get_config()
    @config
  end

end

class OptionParser
  def initialize(argv)
    @opts = {}
    set(argv)
  end
  # Responsable for User input
  def set(argv)
    tmp = argv.shift
    @opts.store(:command, :init) && @opts.store(:file, argv.shift)  if (tmp =~ /init/)
    
    @opts.store(:command, :build) if (tmp =~ /build/)
    @opts.store(:command, :help) if (tmp =~ /help/) or (tmp =~ /h/)
    
    @opts.store(:command, :set) if (tmp =~ /set/)
    @opts.store(:set, argv.shift) if (tmp =~ /set/)
  end
  # Gets selected value from key
  def get(key)
   @opts[key]
  end

end

class Git_Manager
  # Clones selected repo from GitHub
  def get_repo(git_to_clone)
    repo = git_to_clone[:repo]
    branch = git_to_clone[:branch]
    workplace = "#{$SOURCE}/toolchain/arc-gnu-toolchain"
    Git.clone(repo, workplace , branch: "#{branch}")
  end
end

class Manager
  def initialize()
  end
  
  def init(file)
    Config.new(file, Directory_Manager.new())
  end
  
  def build()
    # Reads the User Config file
    config = Config.new()
    # Initialization of instances
    git_manager = Git_Manager.new()
    dir_manager = Directory_Manager.new()

    compiler(config, git_manager, dir_manager)
  end

  def set(str)
    # Reads the User Config file
    config = Config.new()
    # Splits the command              (e.g. prefix=path)
    command = str.split('=').first  # (prefix)
    path = str.split('=').last      # (path)
    
    # Alters path accordingly to the set chosen by user 
    case command
    when 'prefix'
      puts config.get_config()
      params = config.get(:params)
      params.store(:prefix, "#{path}/install")
      config.set(:params, params)
    end


    # Stores file with new data provided by user
    File.open('.config.json', 'w') do |f| 
      f.write JSON.pretty_generate(config.get_config())
    end
  end

  def help()
    puts <<-EOF
    
    usage: ./playground [h] [help] [build] [init <config-file.json] [set <key-to-alter>=<path>]

    These are commands to define different attributes
    
    Start a working area
        init      Creates environment with given config.json file
    
    Run the Framework
        build     Creates all the necessary procedures and install the chosen tools
    
    Different Keys to alter in [set <key-to-alter>=<path>]
        prefix    Path to install root
  
    EOF
    
  end

  
  def get_data()
    return JSON.parse(File.read("#{Dir.getwd}/workload/config.json"), symbolize_names: true)
  end
  
  def check_env(str)
    if str =~ /\$env\(([^)]+)\)/
      puts "ERROR: Variable #{$1} not set"
      exit
    end
  end 
  
  def compiler(config, git_manager, dir_manager)

    #dir_manager.create_directories()
    data = config.get(:builder)
    params = config.get(:params)
    
    # Loop for each tool to be compiled
    data.each do |tool, command|
      
      execute = command[:execute]
    
      execute = process_env(execute, '@SOURCE', "#{$SOURCE}/toolchain/arc-gnu-toolchain/")
      params.each do |key, value| 
#        execute = process_env(execute, key.to_s.upcase, value)
        execute = process_env(execute, key.to_s.upcase, (key == :prefix) ? "#{value}/#{tool}/#{Date.today.to_s.delete! '-'}" : value)
      end
      check_env(execute)
            
      git_manager.get_repo(command[:git]) # PODE DAR EXCEPTION
      dir_manager.create_module_file(params[:prefix], tool)
      dir_manager.create_build_dir(config, tool)
      puts execute

      system(execute)
      exit
    
      Dir.chdir(main_root)
    end 
  end
  
  # Replaces portions of string to specfic data
  def process_env(str, name, subs)
    return str.gsub(/\$env\((#{name})\)/) do |m|
      subs
    end
  end
end

class Main
  def initialize()
    opts = OptionParser.new(ARGV)
    manager = Manager.new()
    main(opts, manager)
  end

  # Main function responsable for setting up the next events
  def main(opts, manager)
    case opts.get(:command)
    when :init
      manager.init(opts.get(:file))
    when :build
      manager.build()
    when :set
      manager.set(opts.get(:set))
    when :help
      manager.help()
    end
    
  end
end

Main.new()
