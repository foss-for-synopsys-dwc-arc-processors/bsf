#!/usr/bin/env ruby
require 'json'
require 'erb'
require 'date'
require 'git'


$SOURCE = "#{Dir.getwd}"

class Directory_Manager
  # Gets Current date to define as version
  def get_version()
    return Date.today.to_s.delete! '-'
  end

  # Creates all main directories
  def create_directories()
    #%w[/modulefiles/ /tools/ /tools/build].each {
    #  |dir| Dir.mkdir ($SOURCE + dir) if !File.directory? ($SOURCE + dir) 
    #}

    %w[/modulefiles/ /tools/ /tools/build].each do |dir|
      Dir.mkdir ($SOURCE + dir) if !File.directory? ($SOURCE + dir)
    end
  
  end

  # Creates Build directory with current tool data
  def create_build_dir(config, name)
    build_dir = "#{$SOURCE}/tools/build/#{name}"
    Dir.mkdir(build_dir) if !File.directory? (build_dir)
    build_dir = "#{build_dir}/#{get_version()}"
    Dir.mkdir(build_dir) if !File.directory? (build_dir)
    Dir.chdir(build_dir)
  end

  def create_module_file(prefix)
    exprex = /\/(.+)\/(.+)\/(.+)$/
    arr = prefix.match(exprex)
    prefix = $1
    name = $2
    version = $3
    
    module_dir = "#{$SOURCE}/modulefiles/#{name}/"
    Dir.mkdir(module_dir) if !File.directory? (module_dir)
    
    p module_dir 

    #template = ERB.new(File.read("#{Dir.getwd}/workload/toolchain.module.erb"))
    #prefix = "#{config.get(:prefix)}"

    template = ERB.new <<-EOF
    whatis("ARC: myModuleName()")
    whatis("Version: myModuleVersion()")

    local pkg = pathJoin("<%= prefix %>", myModuleName(), myModuleVersion())
    prepend_path("PATH", pathJoin(pkg, "bin"))
    prepend_path("LD_LIBRARY_PATH", pathJoin(pkg, "lib"))
    EOF

    File.open("#{module_dir}/#{version}.lua", 'w') do |f|
      f.write template.result(binding)
    end
  end

end

class Config
  def initialize(file = nil, env_manager = nil)

  unless file.nil?
      file = JSON.parse(File.read(file), symbolize_names: true)
      tmp = {}
      tmp.store(:params, "")
      tmp.store(:builder, file)

      #DELETE
      tmp_ = {}
      tmp.store(:params, tmp_)
      #DELETE
      

      #VERIFICAR
      env_manager.check_env_global(tmp[:builder])

      File.open(".config.json", 'w') do |f|
        f.write JSON.pretty_generate(tmp)
      end
    else
      @config = JSON.parse(File.read(".config.json"), symbolize_names: true)
    end
    #@config = file
  end

  # Sets Value to Key
  def set(key, value)
    @config.store(key, value)
  end

  # Gets Value from Key
  def get(key)
    @config[key]
  end

  # Gets Hash
  def get_config()
    @config
  end

end

class OptionParser
  def initialize(argv)
    @opts = {}
    set(argv)
  end
  # Responsable for User input
  def set(argv)
    tmp = argv.shift
    @opts.store(:command, :init) && @opts.store(:file, argv.shift)  if (tmp =~ /init/)

    @opts.store(:command, :build) && @opts.store(:build, argv.shift) if (tmp =~ /build/)

    @opts.store(:command, :help) if (tmp =~ /help/) or (tmp =~ /h/)
    @opts.store(:command, :env_list) if (tmp =~ /env_list/)
    #@opts.store(:command, :env_set) if (tmp =~ /env/)

    @opts.store(:command, :set) if (tmp =~ /set/)
    @opts.store(:set, argv.shift) if (tmp =~ /set/)
  end
  # Gets selected value from key
  def get(key)
   @opts[key]
end

end


class Env_Manager

    def verify_if_env_exists(builder, command)
        arr = get_env_from_json(builder)
        return arr.include? command.upcase
    end

    def env_list()
        config = Config.new()
        env_list = get_env_from_json(config.get(:builder))
        params = config.get(:params).keys
        
        params.map! { |p| p.to_s.upcase } 
                
        env_list.select! { |p| p !~ /\@/ }

        env_list.each do |e|
          if ! params.include? (e)
            puts "\nEnvironment Variable #{e} not defined\n\n"
          else
            value = e.downcase.to_sym
            hash = config.get(:params)
            puts "\nEnvironment Variable #{e} defined: #{hash[value]}\n\n"
          end
          
        end
         
        
    end

    def check_env_global(builder)
        envs = get_env_from_json(builder)
        envs.select! { |a| a =~ /\@/ }
        
        envs = get_global_env_matching(envs)
        
        if ! envs.empty?
            puts <<-EOF
            ERROR: Intern variable/s #{envs} not defined.
            You may try: #{global_variables[0..3]}
            EOF
            exit
        end
    end

    def get_global_env_matching(env)
        arr = []
        env.each do |e|
            tmp = e.gsub("@", "$").to_sym
            arr.append(e) if !global_variables.include? (tmp)
        end
        return arr
    end

    def get_env_variables(str)
        exprex = /\$env\(([^)]+)\)/
        if str =~ exprex
          return str.scan(exprex).flatten
        end
    end

    def get_env_from_json(builder)
        arr = []
        builder.each do |key, value|
          value.each do |key2, value2|
            env_variables = get_env_variables(value2)
            arr.append(env_variables) if env_variables != nil
          end
        end
        return arr.flatten.uniq
    end
    
    def check_if_set(command)
      
      is_set = true
      command.each do |key, value|  
        envs = get_env_variables(value)
        if !envs.nil?
          envs.select! { |env| env !~ /\@/ }
          envs.each do |a|
            puts "ERROR: variable/s #{a} not set"
          end
          is_set = false
        end
      end

      return is_set
    end

    def process_env(str, name, subs)
      return str.gsub(/\$env\((#{name})\)/) do |m|
        subs
      end
    end   
end

class Git_Manager
  # Clones selected repo from GitHub
  def get_repo(git_to_clone)
    repo = git_to_clone[:repo]
    branch = git_to_clone[:branch]
    workplace = "#{$SOURCE}/tools/arc-gnu-toolchain"
    Git.clone(repo, workplace , branch: "#{branch}")
  end
end

class Manager
  def initialize
    @env_manager = Env_Manager.new()
  end

  def init(file)
    Config.new(file, @env_manager)
  end
  
  def env_list()
    @env_manager.env_list()
  end

  def build(filter = nil)
    # Reads the User Config file
    config = Config.new()
    # Initialization of instances
    git_manager = Git_Manager.new()
    dir_manager = Directory_Manager.new()

    compiler(config, git_manager, dir_manager, filter)
  end


  def set(str)
    config = Config.new()
    command = str.split('=').first.downcase
    path = str.split('=').last

    if command =~ /[\@]/
      puts 'ERROR: not a editable variable'
      exit
    end

    if ! @env_manager.verify_if_env_exists(config.get(:builder), command)
      puts "ERROR: #{command.upcase} not a ENV variable"
      exit
    end

    params = config.get(:params)
    params.store(command.to_sym, "#{path}")
    config.set(:params, params)

    File.open('.config.json', 'w') do |f|
      f.write JSON.pretty_generate(config.get_config())
    end
  end

  def help()
    puts <<-EOF
    
    usage: ./playground [h] [help] [build] [env_list] [init <config-file.json] [set <key-to-alter>=<path>]

    These are commands to define different attributes

    Start a working area
        init      Creates environment with given config.json file

    Run the Framework
        build     Creates all the necessary procedures and install the chosen tools

    Different Keys to alter in [set <key-to-alter>=<path>]
        prefix    Path to install root

    EOF

  end


  def get_data()
    return JSON.parse(File.read("#{Dir.getwd}/workload/config.json"), symbolize_names: true)
  end

  def to_filter(data, filter)
    if !filter.nil?
      if data.include?(filter.to_sym)
        data << data.select! { |k, v| k.eql?(filter.to_sym) }
      else
        return false
      end
    end
  end

  def compiler(config, git_manager, dir_manager, filter)
  
    data = config.get(:builder)
    params = config.get(:params)

    if !filter.nil?
      if data.include?(filter.to_sym)
        data.select! { |k, v| k.eql?(filter.to_sym) }
      else 
        puts "Option not valid"
        exit
      end
    end

      
      
      #DELETE
=begin 
      data.each do |tool, command|
        command.each do |key, value|
          envs = @env_manager.get_env_variables(value)
          if !envs.nil?
            envs.each do |env|
              p "Command[key] - #{command[key]}"
              p "env - #{env}"
              p "params[env.downcase.to_sym] - #{env.downcase.to_sym}"
              puts ""
              execute = @env_manager.process_env(command[key], env, params[env.downcase.to_sym])
              p execute
            end
          end
        end
        exit
      end
      exit
      #DELETE
=end
      
      #DELETE
    data.each do |tool, command|

      params.store(:prefix, "#{params[:prefix]}/#{tool}/#{params[:version]}") if !params[:prefix].nil?


      params.each do |param, value|
        command.each do |com, value2|
          next if value2.class == Hash
          tmp = value2
          tmp = @env_manager.process_env(tmp, "@SOURCE", "#{$SOURCE}/tools/arc-gnu-toolchain")
          tmp = @env_manager.process_env(tmp, param.to_s.upcase, value)
          command.store(com, tmp)
        end
      end
    exit if !@env_manager.check_if_set(command)
    execute = command[:execute]

=begin
    exit
      #DELETE
      # Loop for each tool to be compiled
    execute = @env_manager.process_env(execute, '@SOURCE', "#{$SOURCE}/tools/arc-gnu-toolchain/")
    params.each do |key, value|
      execute = @env_manager.process_env(execute, key.to_s.upcase, value)
    end
    puts execute 
    exit
      #  exit if !@env_manager.check_if_set(execute)
    exit if !@env_manager.check_if_set(command)
=end
    dir_manager.create_directories()
    git_manager.get_repo(command[:git]) # PODE DAR EXCEPTION
    dir_manager.create_module_file(params[:prefix])
    dir_manager.create_build_dir(config, tool)
    puts execute
    
   
    system(execute)
    end
  end
end

class Main
  def initialize()
    opts = OptionParser.new(ARGV)
    manager = Manager.new()
    main(opts, manager)
  end

  # Main function responsable for setting up the next events
  def main(opts, manager)
    case opts.get(:command)
    when :init
      manager.init(opts.get(:file))
    when :build
      manager.build(opts.get(:build))
    when :set
      manager.set(opts.get(:set))
    when :env_list
      manager.env_list()
    when :help
      manager.help()
    end
  
    end
  end
  
  Main.new()
