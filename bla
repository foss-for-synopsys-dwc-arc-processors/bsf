#!/usr/bin/env ruby
require 'json'
require 'erb'
require 'date'
require 'git'

$SOURCE = "#{Dir.getwd}"

=begin
class User_Interface
  def self.template_error(module_template)
    puts "ERROR: Module template file not found: #{module_template}"
  end

  def self.variable_error(var, value = nil)
    if value == nil
      puts "Variable #{var} not defined."
    else
      puts "Variable #{var} defined: #{value}"
    end
  end
  
  def self.internal_variable_error(vars)
    puts <<-EOF
    ERROR: Internal Variable/s #{vars} not defined.
    You may try: #{global_variables[0]}
    EOF
  end
  
  def self.variable_not_set_error(var)
    puts "ERROR: Variable #{var} not set."
  end

  def self.git_something_went_wrong_error()
    puts <<-EOF
    \nERROR: Something went wrong.
             Hint: Verify Git Repository URL.
    EOF
  end

  def self.clonning_warning(path_to_clone)
    puts "Cloning into '#{path_to_clone}'..."
  end

end
=end
class Directory_Manager

  def create_dir(path)
    recursive = path.split('/')
    path = ''
    recursive.each do |dir|
      path += dir + '/'
      system("mkdir #{path}") unless File.directory? (path)
    end
  end
  
  def delete_build_dir()
    path = "#{$SOURCE}/tools/build/*"
    system("rm -rf #{path}")
  end

  def create_directories(name, version)
    paths = ["#{$SOURCE}/tools/build/#{name}",
             "#{$SOURCE}/.bla/logs/#{name}"]
    paths.each { |path| create_dir(path) }
  end
 
  def check_module_file module_file
    module_template = module_file[:template]
    if !File.exists? module_template
      puts "ERROR: Module template file not found: #{module_template}"
      exit
    end
  end

  def create_module_file(prefix, module_file)
   
    module_prefix = module_file[:prefix]
    module_template = module_file[:template]

    exprex = /\/(.+)\/(.+)\/(.+)$/
    arr = prefix.match(exprex)
    prefix = $1
    name = $2
    version = $3

    module_dir = "#{module_prefix}/#{name}/"
    create_dir(module_dir)

    template = ERB.new(File.read(module_template))
    
    File.open("#{module_dir}/#{version}.lua", 'w') do |f|
      f.write template.result(binding)
    end
  end
end

class Config
  def initialize(file = nil, var_manager = nil)

    unless file.nil?
      file = get_json(file)
      
      config = {}
      config.store(:params, {})
      config.store(:builder, file)

      var_manager.check_var_global(config[:builder])
      
      set_json(config)
    else
      @config = get_json()
    end
  end
 
  def get_json(file = '.bla/config.json')
    return JSON.parse(File.read(file), symbolize_names: true)
  end 

  def set_json(config = @config)
    Dir.chdir $SOURCE
    Dir.mkdir ".bla" if !File.directory? ".bla"
    File.open('.bla/config.json', 'w') do |f|
      f.write JSON.pretty_generate(config)
    end
  end
  
  # Sets Value to Key
  def set(key, value)
    @config.store(key, value)
  end

  # Gets Value from Key
  def get(key)
    @config[key]
  end

  # Gets Hash
  def get_config()
    @config
  end

end

class OptionParser
  def initialize(argv)
    @opts = {}
    set(argv)
  end
  def set(argv)
    tmp = argv.shift
    @opts.store(:command, :init) && @opts.store(:file, argv.shift)  if (tmp =~ /init/)
    @opts.store(:command, :build) && @opts.store(:build, argv.shift) if (tmp =~ /build/)
    @opts.store(:command, :log) && @opts.store(:log, argv.shift) if (tmp =~ /log/)
    @opts.store(:command, :help) if (tmp =~ /help/) or (tmp =~ /h/)
    @opts.store(:command, :var_list) if (tmp =~ /var_list/)
    @opts.store(:command, :set) && @opts.store(:set, argv.shift) if (tmp =~ /set/)
    @opts.store(:command, :repo_list) if tmp =~ /repo_list/
    @opts.store(:command, :status) && @opts.store(:status, argv.shift) if tmp =~ /status/
    @opts.store(:command, :commit) if tmp =~ /commit/
    @opts.store(:command, :clone) if tmp =~ /clone/
  end
 
  def get(key)
   @opts[key]
  end
end


class Env_Manager

    def verify_if_var_exists(builder, command)
        arr = get_var_from_json(builder)
        return arr.include? command.upcase
    end

    def var_list()
        config = Config.new()
        var_list = get_var_from_json(config.get(:builder))
        params = config.get(:params).keys
        
        params.map! { |p| p.to_s.upcase }            
        var_list.select! { |p| p !~ /\@/ }

        var_list.each do |e|
          if ! params.include? (e)
            puts "Internal Variable #{e} not defined"
          else
            value = e.downcase.to_sym
            hash = config.get(:params)
            puts "Internal Variable #{e} defined: #{hash[value]}"
          end
        end
    end

    def check_var_global(builder)
        vars = get_var_from_json(builder)
        
        vars.select! { |a| a =~ /\@/ }
        vars = get_global_var_matching(vars)
        
        if !vars.empty?
           puts <<-EOF
            ERROR: Intern variable/s #{vars} not defined.
            You may try: #{global_variables[0..3]}
            EOF
            exit
        end
    end

    def get_global_var_matching(vars)
        arr = []
        vars.each do |var|
            tmp = var.gsub("@", "$").to_sym
            arr.append(var) if !global_variables.include? (tmp)
        end
        return arr
    end

    def get_var_variables(str)
        exprex = /\$var\(([^)]+)\)/
        if str =~ exprex
          return str.scan(exprex).flatten
        end
    end

    def get_var_from_json_recursive(to_each, arr)
      to_each.each do |key, value|
        var_variables = (value.class == Hash) ? get_var_from_json_recursive(value, arr) : get_var_variables(value)
        arr.append(var_variables) if var_variables != nil
      end
      return arr.flatten.uniq
    end

    def get_var_from_json(builder)
        arr = get_var_from_json_recursive(builder, [])
        return arr.flatten.uniq
    end
    
    def check_if_set(command)
      is_set = true
      command.each do |key, value|  
        vars = get_var_variables(value)
        if !vars.nil?
          vars.select! { |var| var !~ /\@/ }
          vars.each do |var|
            puts "ERROR: variable #{var} not set"
          end
          is_set = false
        end
      end

      return is_set
    end

    def process_var(str, name, subs)
      return str.gsub(/\$var\((#{name})\)/) do |m|
        subs
      end
    end   
end

class Git_Manager
  
  attr_reader :name
  def initialize
    @internal_repo = 'https://github.com/luiss-synopsys/test.git'
  end

  def set_git(git_info)
    @repo = git_info[:repo]
    @branch = git_info[:branch]
    @name = get_repo_name(@repo)
    @path_to_clone = "#{$SOURCE}/tools/#{@name}"
  end
    
  def commit()
    #testing
    env_dir = "#{$SOURCE}/.bla"
    Dir.chdir(env_dir)
    
    create_env() if !File.directory? '.git'
    
    system 'git add .'
    commit_msg = get_commit_msg("#{$SOURCE}/tools")
    Dir.chdir(env_dir)
    system "git commit -m '#{commit_msg}'"
    system 'git push origin main --force' 
  end

  def create_env()
    Dir.chdir "#{$SOURCE}/.bla"
    system 'git init'
    system "git remote add origin #{@internal_repo}"
    system 'git branch -M main'
  end

  def get_commit_msg(prefix)
    
    Dir.chdir(prefix)
    
    main_hash = `git log -1 --format=format:"%H"`
    config = {}
    
    folders = Dir.glob('*').select { |f| File.directory? f }
    folders.each do |folder|
      Dir.chdir(folder)
      hash = `git log -1 --format=format:"%H"`
     
      if hash == main_hash
        Dir.chdir('./..')
        next
      end

      if File.file? ("versions.json")
        file = JSON.parse(File.read("versions.json"))
        config.store(folder, file)
      else
        config.store(folder, hash)
      end
      Dir.chdir(prefix)
    end
    return JSON.pretty_generate(config)

  end

  def internal_git(command)
    Dir.chdir "#{$SOURCE}/.bla"
    system "git #{command}"
  end

  def get_clone_framework(branch = 'main')
    path_to_clone = "#{$SOURCE}/.bla"
    system("git clone --branch #{branch} #{@internal_repo} #{path_to_clone}")
    #system "git clone --branch #{branch} https://github.com/luiss-synopsys/test.git #{path_to_clone}"
  end

  def get_clone()
    
    if File.directory? (@path_to_clone)
      return
    end

    git = "git clone --branch #{@branch} #{@repo} #{@path_to_clone}"
    puts "Cloning into '#{@path_to_clone}'..."
    isCloned = system("#{git} > /dev/null 2>&1")
    if !isCloned
      puts <<-EOF
\nERROR: Something went wrong.
       Hint: Verify Git Repository URL.
       EOF
      exit
    end
  end

  def if_already_exists(path_to_clone)
    return File.directory? @path_to_clone   
  end

  def fetch_repo(path_to_clone)
    to_execute = "git fetch #{path_to_clone}"
    isFetched = system(to_execute)

    if !isFetched
      puts <<-EOF
\nERROR: Something went wrong.
       Hint: Verify Git Repository URL
      EOF
      exit
    end
  end
  
  def check_up_to_date(repo)
    path = "#{$SOURCE}/tools/#{repo}"
    Dir.chdir path

    output_exec = `git status -uno`
    puts output_exec
  
    return output_exec =~ /up\sto\sdate/
  end

  def get_repo_list()
    repos = Dir.glob("#{$SOURCE}/tools/*/.git")
    repos.map! { |repo| repo.split('/')[-2] }
    repos.each do |repo|
      puts repo + ":"
      #check_up_to_date(repo)
      Dir.chdir "#{$SOURCE}/tools/#{repo}"
      puts `git status -uno`.split('.')[0]
    end

  end

  def get_repo_name(repo)
    exprex = /\.git/
    name = repo.split('/').last
    name = name.gsub(exprex, '') if name =~ exprex
    return name
  end
end

class Status_Manager

 attr_reader :status
 def initialize
   @path_to_status = "#{$SOURCE}/.bla/logs/status.json"
    @status = (!File.file? @path_to_status) ?
      {} : JSON.parse(File.read(@path_to_status), symbolize_names: true)
  end
  
  def set_status(status, tool)
    
    Dir.chdir($SOURCE)
    status_msg = status ? "Passed" : "Failed. check logs: ./bla log #{tool}"
    puts status_msg
  
    @status.store(status_msg.to_sym, tool)
    File.open(@path_to_status, 'w') do |f|
      f.write JSON.pretty_generate(@status)
    end
  end

end

class Manager
  def initialize
    @var_manager = Env_Manager.new()
    @git_manager = Git_Manager.new()
    @status_manager = Status_Manager.new()
  end

  def init(file)
    Config.new(file, @var_manager)
  end
  
  def clone()
    @git_manager.get_clone_framework()
  end
  def commit()
    @git_manager.commit()
  end

  def status(tool)
    if tool.nil?
      status = @status_manager.status
      status.each { |k, v| puts "#{k}: #{v}" }
    else
      status = @status_manager.status[tool.to_sym]
      puts status
    end
  end


  def var_list()
    @var_manager.var_list()
  end
  
  def log(name_version)
  
    begin    
      path_from = "#{$SOURCE}/.bla/logs/#{name_version}/make.log"
     # path_to = "#{$SOURCE}/#{name_version.sub('/','.')}.make.log"
    #  to_execute = "cp #{path_from} #{path_to}"
      isInstalled = system("cat #{path_from}")
      if !isInstalled
        puts "ERROR: Tool not found"
      end
    rescue
      puts <<-EOF
ERROR: Something went wrong.
       Hint: Try 'bla log [NAME_OF_TOOL]'
      EOF
    end
  end
 
  def repo_list()
    @git_manager.get_repo_list()

  end

  def build(filter = nil)
    # Reads the User Config file
    config = Config.new()
    # Initialization of instances
    git_manager = Git_Manager.new()
    dir_manager = Directory_Manager.new()

    compiler(config, git_manager, dir_manager, filter)
  end


  def set(str)
    config = Config.new()
    command = str.split('=').first.downcase
    path = str.split('=').last

    if command =~ /[\@]/
      puts 'ERROR: not a editable variable'
      exit
    end

    if ! @var_manager.verify_if_var_exists(config.get(:builder), command)
      puts "ERROR: #{command.upcase} not a variable"
      exit
    end

    params = config.get(:params)
    params.store(command.to_sym, "#{path}")
    config.set(:params, params)

    config.set_json()

  end

  def help()
    puts <<-EOF
    EOF

  end


  def get_data()
    return JSON.parse(File.read("#{Dir.getwd}/workload/config.json"), symbolize_names: true)
  end

  def to_filter(data, filter)
    if !filter.nil?
      if data.include?(filter.to_sym)
        data << data.select! { |k, v| k.eql?(filter.to_sym) }
      else
        return false
      end
    end
  end

  def filter_tool(data, to_filter)
    
    return data if to_filter.nil?
    
    to_filter = to_filter.to_sym 
    if !data.include? to_filter
      puts "ERROR: Option Invalid!"
      exit 
    end 
    
    return data.select! { |key| key.eql? to_filter }
  end
  
  def to_process(value, key_param, value_param)
    processed_var = @var_manager.process_var(value, key_param.to_s.upcase, value_param)
    return processed_var
  end

  def to_each(to_each_var, key_param, value_param)
    tmp = to_each_var
    tmp.each do |key, value|
      to_store_value = (value.class == Hash) ? to_each(value, key_param, value_param) : processed_var = to_process(value, key_param, value_param)

      to_each_var.store(key, to_store_value)
    end

    to_each_var = tmp
    return to_each_var
  end

  def compiler(config, git_manager, dir_manager, to_filter)
  
    data = config.get(:builder)
    params = config.get(:params)
    
    internal_params = params
    prefix  = internal_params[:prefix]
    version = internal_params[:version]

    data = filter_tool(data, to_filter)
    data.each do |tool, command|
      
      prefix_path_to_store = "#{prefix}/#{tool}/#{version}" 
      internal_params.store(:prefix, prefix_path_to_store) if !prefix.nil?
      prefix = internal_params[:prefix]

      git_manager.set_git(command[:git]) 
      internal_params.store(:@SOURCE, "#{$SOURCE}/tools/#{git_manager.name}") 

      internal_params.each do |key_param, value_param|
        to_each(command, key_param, value_param)
      end
    
      exit if !@var_manager.check_if_set(command)
    
      dir_manager.create_directories(tool, version)
      git_manager.get_clone()
      dir_manager.check_module_file(command[:module_file]) if command.has_key? :module_file


      Dir.chdir ("#{$SOURCE}/tools/build/#{tool}") 
      path_make_log = "#{$SOURCE}/.bla/logs/#{tool}/make.log"
      out = File.open(path_make_log, 'w')
      puts "Installing #{tool}.."
      status = system(command[:execute], out: out, err: out)
      out.close()
    
  
      if status and command.has_key? :module_file
        dir_manager.create_module_file(prefix, command[:module_file])
      end
      @status_manager.set_status(status, tool)
      
      dir_manager.delete_build_dir()
    end

    #git_manager.get_commit_msg('/scratch/luiss/project/framework/tes/tools')
  end
end



class Main
  def initialize()
    opts = OptionParser.new(ARGV)
    manager = Manager.new()
    main(opts, manager)

    #
    #Git_Manager.new().get_commit_msg("/scratch/luiss/project/framework/tes/tools")
    exit
  end

  def main(opts, manager)
    case opts.get(:command)
    when :init
      manager.init(opts.get(:file))
    when :build
      manager.build(opts.get(:build))
    when :set
      manager.set(opts.get(:set))
    when :var_list
      manager.var_list()
    when :repo_list
      manager.repo_list()
    when :status
      manager.status(opts.get(:status))
    when :log
      manager.log(opts.get(:log))
    when :help
      manager.help()
    when :commit
      manager.commit()
    when :clone
      manager.clone()
    else
      puts "ERROR: Invalid Operation"
    end
    
  end
end
  
Main.new()
